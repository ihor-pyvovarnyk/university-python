Лекція 13: Автоматизоване тестування
====================================

# Вступ

Виявлення помилок (тестування) завжди було невід’ємною частиною розробки програмного забезпечення (ПЗ). Причини помилок можуть бути різноманітні: неправильна реалізація алгоритмів, неочікувані вхідні дані, помилки у сторонньому ПЗ необхідному для роботи системи. Тестування дозволяє виявляти такі помилки, а його інтеграція в процес розробки дозволяє виявляти їх раніше.

Навіть попередньо протестована програма, після внесення будь-яких змін стає таким-собі котом Шредінгера, не можна бути впевненим чи працює вона коректно чи ні допоки це не буде явно перевірено. Тестування після внесення змін дозволяє легко перевірити коректність роботи як вже зробленого так і нового функціоналу, а його автоматизація робить цей процес швидким.

У сфері розробки ПЗ помилки часто називають англіцизмом “баг” чи ”баґ” (англ. Bug – жук, комаха). Широкому використанню даного терміну сприяв інцидент з Гарвардським комп’ютером Марк ІІ, коли Ґрейс Гоппер виявила, що причиною некоректної роботи комп’ютера стала міль, що застрягла у реле [*].

Хоч за роки розвитку індустрії розробки ПЗ способи та інструменти, що використовуються для виявлення помилок, змінювались на розвивались, однак мета залишилась тією самою: виявлення та локалізація помилок, прагнення до забезпечення повторюваності результатів перевірок.

В даній лекції будуть розглянуті основи теорії тестування ПЗ, а також інструменти, що використовуються для написання автоматизованих тестів мовою Python.

\* Rear Admiral Grace Murray Hopper (http://ei.cs.vt.edu/~history/Hopper.Danis.html)

# Основи теорії тестування програмного забезпечення

Тестування програмного забезпечення — це процес дослідження програмного забезпечення для виявлення інформації про якість цього програмного забезпечення відносно контексту в якому воно має використовуватись. 

## Типи тестування

### Функціональне та нефункціональне тестування

Базуючись на такому широкому визначення тестування ПЗ виділяють такі два типи тестування:

* Функціональне (Functional) — тестування функціоналу системи, що заданий документацією чи описом того, як користувач має з системою взаємодіяти; функціональне тестування відповідає на питання “чи може користувач виконувати певну дію?” або “чи якийсь конкретний шматок функціоналу працює коректно?”;
* Нефункціональне (Non-functional) — стосується аспектів програмного забезпечення, що напряму не стосуються конкретної частини функціоналу чи взаємодії з користувачем, наприклад: масштабування, швидкість роботи, відповідність стандартам безпеки і т.д.

Часто розробники обмежуються лише функціональним тестуванням, покладаючись на нефункціональні характеристики сторонніх бібліотек та інструментів, що використовує система. Однак іноді причина нефункціональних проблем є саме у коді системи, незважаючи на швидкодію чи безпеку сторонніх компонентів. Також самі сторонні компоненти іноді можуть не відповідати нефункціональним вимогам, що може створити серйозні проблеми якщо архітектура системи побудована навколо цих сторонніх компонентів.

### Ручне та автоматизоване тестування

У контексті способу виконання тестів виділяють ручне та автоматизоване тестування:

* Ручне тестування — тестування системи виконується людиною;
* Автоматизоване тестування — тестування системи виконується іншою програмою, а людина лише ініціює цей процес.

Перевагою ручного тестування є простота та можливість розпочати тестування швидко. Недоліком є низька швидкість виконання тестів, постійне повторення набору тестів після кожної зміни займає багато часу.

Перевагою автоматизованого тестування є швидкість виконання, адже тестування відбувається автоматично та не потребує нагляду людини. Це дозволяє запускати такі тести не тільки по завершенню виконання завдання а й протягом процесу розробки, перевіряючи вплив нового коду на старий функціонал та добавляти нові тести для нового функціоналу. Недоліком автоматизованих тестів є те, що їх розробка може займати багато часу. 

Не всі проблеми з ПЗ можна виявити через автоматизоване тестування, наприклад неправильне відображення зображення браузером важко було б протестувати автоматично. Однак, завдяки своїй швидкості виконання, рекомендується використання автоматизованих тестів як основи, що перевіряє більшу частину функціональних та нефункціональних вимог до системи.

Можна також виділити напівавтоматичне тестування, коли частина роботи виконується автоматично але для виконання тесту чи оцінки результатів необхідне втручання людини.

### Димове тестування

Димове тестування (англ. Smoke testing) — це підхід до тестування, що передбачає виконання мінімально необхідного набору тестів. Ціль димового тестування — перевірити наявність критичних помилок у програмному забезпеченні та оцінити необхідність у подальному тестуванні. Назва цього виду тестування походить під підходу у радіоелектроніці коли після ремонту чи заміни частини обладнання, його просто включали і якщо з нього не йшло диму, то тест вважався пройденим [*]. 

Димове тестування може бути як ручним так і автоматизованим. В ручному тестуванні якщо ПЗ не проходить димове тестування, то подальше тестування не буде виконаним допоки виявлені проблеми не будуть вирішені.   В автоматизованому тестуванні димове тестування часто представляє собою визначення певного порядку у виконанні тестів різного виду, наприклад, спочатку тестуються компоненти системи, а тільки потім тестування всієї системи з програмною симуляцією дій користувача. 

\* Guidelines for Smoke Testing (https://docs.microsoft.com/en-us/previous-versions/ms182613(v=vs.80))

## Рівні тестування [*]

\* Introduction to software testing P Ammann, J Offutt - 2016 - Cambridge University Press (ст. 5-8) (http://lib.sgu.edu.vn:84/dspace/bitstream/TTHLDHSG/2791/1/Introduction%20to%20Software%20Testing.pdf)

Тестування ПЗ можна виконувати на різних рівнях: від функціональних вимог перед всією системою до конкретної реалізації алгоритмів.  Перерахуємо рівні тестування та їх визначення починаючи від орієнтованих на користувацький функціонал до орієнтованих на конкретну реалізацію:

* Приймальне тестування (англ. Acceptance testing) — оцінює чи ПЗ вирішує проблеми для вирішення яких воно розроблялось (наприклад, якщо ціллю було прискорення якогось процесу чи дійсно цей процес був прискорений завдяки розробленому ПЗ);
* Системне тестування (англ. System testing) — оцінює чи ПЗ відповідає вимогам технічної специфікації специфікації (наприклад, чи може користувач авторизуватись, виконати операції, що були визначені специфікацією);
* Інтеграційне тестування (англ. Integration testing) — оцінює чи компоненти підсистеми ПЗ для виконання певного завдання працюють коректно (наприклад, чи коректно працює підсистема, що відповідає за авторизацію користувачів)
* Модульне тестування (англ. Module testing) — оцінює чи коректно працюють окремі модулі підсистем ПЗ (наприклад, чи коректно працює модуль відповідальний за пагінацію);
* Компонентне або Юніт тестування (англ. Unit testing) — оцінює найдрібніші компоненти системи (функції, класи) (наприклад, чи коректно працює клас, що репрезентує користувача у системі).

Варто зазначити, що наведені рівні тестування не мають чітко виділених меж, а є скоріш континуумом тестування від загального до детального. Так, модульне тестування часто включають в інтеграційне тестування і в результаті виходить континуум тестування можливих комбінацій дрібних компонентів системи (як окремих модулів так і цілих підсистем чи груп підсистем) але не всієї системи.

Також виділяють end-to-end тестування (або E2E, від початку до кінця), що є по-суті приймальним тестуванням, як правило автоматизованим. End-to-end тестування, на відміну від системного тестування тестує на конкретний функціонал, а процес симуляції виконання користувачем певного завдання, що система має вирішувати, наприклад, для тестування інтернет-магазину користувач може ввести в пошук назву товару, добавити його в корзину та оформити замовлення.

### Переваги та недоліки різних рівнів тестування

На діаграмі нижче порівнюються різні рівні тестування за наступним набором характеристик: складність автоматизації, тривалість виконання, складність локалізації помилок, віддаленість від кінцевого користувача та легкість рефакторингу (перетворення програмного коду для полегшення розуміння коду і легшого внесення подальших змін без зміни зовнішньої поведінки самої системи).

![Переваги та недоліки різних рівнів тестування](assets/1.png)

Системне тестування дозволяє тестувати тестувати безпосередньо функціонал, що буде використовувати користувач, і тому найточніше показує коректність системи з точки зору користувача але тести системного рівня найважче автоматизовувати (необхідно запускати усю систему та інструменти, що дозволяють симулювати поведінку користувача), їх виконання займає багато часу (часто великий набір таких тестів виконують протягом ночі, а зранку оцінюють результати), локалізація помилок при такому підході може бути проблематичною (необхідно з високорівневого тесту зрозуміти де в ПЗ виникла помилка,  що може знаходитись в компонентах від найвищого до найнищого рівня абстракції), а робить рефакторінг простим (покращення коду без зміни функціоналу), адже ми не прив’язуємося до внутрішньої реалізації системи, нам важлива тільки зовнішня поведінка.

Юніт тестування легко автоматизувати (по-суті завжди автоматизоване), вони виконуються швидко (секунди – десятки секунд) та дозволяють легко локалізувати помилк, оскільки тестуються найдрібніші компоненти системи. Недоліком є віддаленість від користувача, цілком ймовірною є ситуація коли всі юніт-тести проходять успішно, але на рівні користувача існує помилка тому, що тести певного компоненту не передбачають можливість певної поведінки. Також недоліком є складність рефакторінгу, оскільки, хоча ми і можемо легко здійснювати рефакторінг дрібних компонентів системи, архітектурні зміни потребують серйозних змін не тільки в коді ПЗ, а й в тестах.

Інтеграційне та модульне тестування усереднює переваги та недоліки системного та юніт тестування.

### Висновки до рівнів тестування

При визначенні стратегії тестування певного ПЗ використовують різні підходи, інколи вибирають лише один (наприклад лише юніт тестування), інколи кілька. Хорошою практикою вважається поєднання тестів у так-звану піраміду тестів, де основу складають юніт-тести, які є найбільш чисельними, далі менша кількість інтеграційних тестів і нарешті системні та E2E тести. Таких підхід дозволяє поєднувати переваги кожного з видів тестів, мати швидкий спосіб перевірки коректності за допомогою юніт-тестів, що перевіряють усю систему та перевіряти найважливіший функціонал з точки зору користувача за допомогою відносно невеликої кількості системних та E3E тестів.

![Рівні тестування](assets/2.png)

# Тестування у документації (пакет doctest)

## Вступ

### Інтерактивний режим інтерпритатора (REPL)

Інтерпретовані мови програмування, як правило, мають інтерактивний режим, або REPL, від англ. Read-eval-print loop, що дозволяє вводити рядки коду та одразу бачити результат їх виконання. Абревіатура REPL описує процес цикл через який проходить інтерпретатор при кожному новому вводі від користувача: read (читання вводу користувача), evaluate (виконання коду, введеного користувачем) та print (виведення результатів виконання).

Для входження в інтерактивний режим інтерпретатора Python необхідно виконати в терміналі команду “python” без додаткових аргументів:

```shell
$ python
Python 3.6.3 (default, Oct 14 2017, 15:56:35) 
[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.37)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> 
```

Після символів “>>>” можна вводити код для виконання інтерпретатором. При вводі коду на кілька рядків, наприклад при введені коду функції чи класу, замість символів “>>>” в наступних рядках з’являться символи “...”:

```python
>>> print("Hello, world")
Hello, world
>>> def sum(a, b):
...     return a + b
...
>>> sum(2, 3)
5
```

### Документуючі стрічки (англ, docstring) *

\* PEP 257 -- Docstring Conventions (https://www.python.org/dev/peps/pep-0257/)

У більшості мов програмування документування функцій та класів виконується за допомогою коментарів. В Python використовується інших підхід, що дозволяє тісно інтегрувати документацію в саму мову.
 
В Python документація визначається необов’язковим літералом стрічки, який є першим виразом у модулі, функції, класі чи методі класу. Такі стрічки називаються документуючими стрічками.

Вміст документуючих стрічок автоматично додається до атрибуту __doc__ модуля, функції, класу чи методу класу.

Нижче наведений приклад, що ілюструє як працюють документуючі стрічки в Python на прикладі функції:

```python
>>> def add(a, b):   
...     """
...     Документація до функції описує що функція робить, 
...     а також її аргументи та значення, що повертається.
...     Add two numbers.
...     
...     :type a: int
...     :param a: First number
...     :type b: int
...     :param b: Second number
...     :rtype: int
...     :return: Sum of two numbers
...     """
...     return a + b
... 
>>> add.__doc__
'\n\tДокументація до функції описує що функція робить, \n\tа також її аргументи та значення, що повертається.\n\tAdd two numbers.\n\t\n\t:type a: int\n\t:param a: First number\n\t:type b: int\n\t:param b: Second number\n\t:rtype: int\n\t:return: Sum of two numbers\n\t'
```

Вміст документуючих стрічок можу бути яким завгодно, однак для опису аргументів та значень, що повертаються, краще притримуватись чітко визначеного формату.
 
Існує багато таких форматів документації: наприклад: reStructuredText (використаний у раніше наведеному прикладі), epydoc, numpydoc та інші.
 
Чітко визначений формат документування дозволяє використовувати інструменти автоматичного генерування документації, коли з коду витягується вся документація та перетворюється, наприклад, у HTML чи PDF документ. Також часто інтегровані середовища розробки (IDE) використовують дані з документуючих стрічок описаних у таких форматах для статичного аналізу коду, що дозволяє виявити деякі помилки ще до запуску програми.

### Спеціальна змінна __name__

При виконання Python файлу інтерпретатор добавляє деякі спеціальні змінні, одна з таких змінних є “__name__”. Дана змінна містить стрічку з ім’ям поточного модуля коли модуль імпортується, однак коли модуль безпосередньо виконується, ця змінна містить стрічку “__main__”.

Для ілюстрації роботи даної змінної використаємо наступний Python-файл:

`main.py`
```python
print(__name__)
```

Імпортуємо даний файл з інтерактивного режиму інтерпретатора:

```python
>>> import main
main
```

Тепер запустимо даний файл безпосередньо:

```shell
$ python main.py 
__main__
```

Дану особливість цієї змінної часто використовують щоб модуль поводив себе по-різному залежно від того чи він був імпортований, чи безпосередньо виконаний. Для цього в кінець файлу додають наступну конструкцію:

`main.py`
```python
...
if __name__ == '__main__':
    # код, що виконується тільки тільки
    # якщо файл виконується безпосередньо
    ...
```

Приклад використання:

`main.py`
```python
def main():
    ...

if __name__ == '__main__':
    main()
```

В даному прикладі функцію “main” можна імпортувати без її виконання, однак якщо запустити модуль безпосередньо, то функція буде виконана.

### Приклад

Практикувати автоматизоване тестування будемо з використанням даної функції, що визначає координати пересічення двох прямих, де пряма представлена рівнянням (Ax + By + C = 0):

`main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """Finds the intersection point of two lines."""
    x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
    y = (a1*c2 - a2*c1) / (a1*b2 - a2*b1)
    return x, y
```

## Тести у документації (пакет doctest)

Модуль doctest дозволяє шукати в документації до функцій фрагменти, що схожі на інтерактивні сесії інтерпретатора Python та виконує їх.

Такий формат опису використання методів, функції, класів чи їх методів використовується для автоматизованого тестування або для прикладів використання.

Запустимо інтерактивний режим інтерпретатора та перевіримо виконання функції на готовому прикладі:

```python
>>> from main import intersection
>>> intersection(1, 2, 5, -1, 2, 3)
(1.0, 2.0)
```

Тепер даний вивід інтерактивного режиму інтерпретатора можна скопіювати і вставити у документуючу стрічку:

`main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> from main import intersection
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    """
    ...
```

Оскільки даний код знаходиться у тому ж файлі, що і функція, яка там використовується, імпортувати її не потрібно, тому даний рядок можна забрати.

`main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    """
    ...
```

Для того, щоб даний тест у документації виконався в кінець модуля добавимо наступний код, який запускає тести у документації, що визначені в даному модулі:

`main.py`
```python
...
if __name__ == '__main__':
    import doctest
    doctest.testmod()
```

Тепер модуль виглядає наступним чином:

`main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    """
    x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
    y = (a1*c2 - a2*c1) / (a1*b2 - a2*b1)
    return x, y

if __name__ == '__main__':
    import doctest
    doctest.testmod()
```

### Запуск тестів у документації

#### doctest.testmod

Для того, щоб запустити тести виконаємо наступну команду:

```shell
$ python main.py -v
Trying:
    intersection(1, 2, 5, -1, 2, 3)
Expecting:
    (1.0, 2.0)
ok
1 items had no tests:
    __main__
1 items passed all tests:
   1 tests in __main__.intersection
1 tests in 2 items.
1 passed and 0 failed.
Test passed.
```

З виводу команди бачимо, що тест виконався успішно. Тепер змінимо код функції так, щоб тест не проходив:

`incorrect_main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    """
    return (0, 0)
...
```

Запустимо тест знову та очікувано бачимо повідомлення про помилку:

```shell
$ python incorrect_main.py -v 
Trying:
    intersection(1, 2, 5, -1, 2, 3)
Expecting:
    (1.0, 2.0)
**********************************************************************
File "incorrect_main.py", line 4, in __main__.intersection
Failed example:
    intersection(1, 2, 5, -1, 2, 3)
Expected:
    (1.0, 2.0)
Got:
    (0, 0)
1 items had no tests:
    __main__
**********************************************************************
1 items had failures:
   1 of   1 in __main__.intersection
1 tests in 2 items.
0 passed and 1 failed.
***Test Failed*** 1 failures.
```

В виводі ми бачимо який саме тест не пройшов та яке значення було отримане замість очікуваного.

При запуску тестів ми передавали додатковий параметр “-v” (від англ. verbosity), щоб увімкнути розширений вивід. Без даного параметру при успішному виконанні всіх тестів вивід буде відсутній, тому може бути не зрозуміло чи дійсно тести виконались.
 
Запустимо тести без розширеного виводу:

```shell
$ python main.py
$  
```

Вивід відсутній, Тепер запустимо тест з некоректною версією функції:

```shell
$ python incorrect_main.py   
**********************************************************************
File "incorrect_main.py", line 4, in __main__.intersection
Failed example:
    intersection(1, 2, 5, -1, 2, 3)
Expected:
    (1.0, 2.0)
Got:
    (0, 0)
**********************************************************************
1 items had failures:
   1 of   1 in __main__.intersection
***Test Failed*** 1 failures.
```

#### python -m doctest

Деякі пакети зі стандартної бібліотеки Python дозволяють виконувати певні дії коли замість імпортування вони використовуються як команди, тобто наступним чином:

```shell
$ python -m <назва модуля>
```

Таку особливу поведінку має і пакет doctest. При запуску його як команди він дозволяє запускати тести у документуючих стрічках в переданому модулі.
 
Запускаючи тести таким чином не потрібно вказувати наступний код в кінця файлу:

`main.py`
```python
...
if __name__ == '__main__':
    import doctest
    doctest.testmod()
```

Видалимо його, щоб код програми виглядав наступним чином:

`main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    """
    x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
    y = (a1*c2 - a2*c1) / (a1*b2 - a2*b1)
    return x, y
```

Тепер запустимо тест у документуючій стрічці використовуючи пакет doctest як команду:

```shell
$ python -m doctest main.py
$ 
```

Як і раніше при успішному виконанні тестів вивід відсутній, добавимо параметр “-v” для розширеного виводу:

```shell
$ python -m doctest main.py -v
Trying:
    intersection(1, 2, 5, -1, 2, 3)
Expecting:
    (1.0, 2.0)
ok
1 items had no tests:
    main
1 items passed all tests:
   1 tests in main.intersection
1 tests in 2 items.
1 passed and 0 failed.
Test passed.
```

Запустимо і тести для некоректної версії функції, щоб переконатись, що помилки відображаються як очікувалось.

```shell
$ python -m doctest incorrect_main.py 
**********************************************************************
File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/2_doctest/v5/incorrect_main.py", line 4, in incorrect_main.intersection
Failed example:
    intersection(1, 2, 5, -1, 2, 3)
Expected:
    (1.0, 2.0)
Got:
    (0, 0)
**********************************************************************
1 items had failures:
   1 of   1 in incorrect_main.intersection
***Test Failed*** 1 failures.
```

### Тестування винятків

Тестуючи код програм важливо тестувати і очікувані помилки. У нашому прикладі, функція викидує виняток ZeroDivisionError якщо лінії є паралельними, а отже і точки перетину вони не мають. Добавимо додатковий тест, що перевіряє цю особливість роботи функції. Для початку спробуємо перевірити як веде себе функція у даному сценарії в інтерактивному режимі інтерпретатора:

```python
>>> from main import intersection
>>> intersection(1, 1, 2, 1, 1, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/2_doctest/v5/main.py", line 7, in intersection
    x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
ZeroDivisionError: division by zero
```

Скопіюємо дану інтерактивну сесію та додамо у документуючу стрічку:

`main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    >>> intersection(1, 1, 2, 1, 1, 3)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/2_doctest/v5/main.py", line 7, in intersection
        x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
    ZeroDivisionError: division by zero
    """
    x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
    y = (a1*c2 - a2*c1) / (a1*b2 - a2*b1)
    return x, y
```

У тесті в документації ми вказали також стек викликів, що був виведений інтерпретатором в інтерактивному режимі. Оскільки текст стеку викликів може бути різним залежно від того де програма запускається, пакет “doctest” ігнорує його, а оскільки він ігнорується, то як правило його замінюють на “...”:

`main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    >>> intersection(1, 1, 2, 1, 1, 3)
    Traceback (most recent call last):
      ...
    ZeroDivisionError: division by zero
    """
    x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
    y = (a1*c2 - a2*c1) / (a1*b2 - a2*b1)
    return x, y
```

Запустимо тести знову та бачимо, що:

```shell
$ python -m doctest main.py -v
Trying:
    intersection(1, 2, 5, -1, 2, 3)
Expecting:
    (1.0, 2.0)
ok
Trying:
    intersection(1, 1, 2, 1, 1, 3)
Expecting:
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/2_doctest/v5/main.py", line 7, in intersection
        x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
    ZeroDivisionError: division by zero
ok
1 items had no tests:
    main
1 items passed all tests:
   2 tests in main.intersection
2 tests in 2 items.
2 passed and 0 failed.
Test passed.
```

Додамо аналогічний текст до некоректної версії функції:

`incorrect_main.py`
```python
def intersection(a1, b1, c1, a2, b2, c2):
    """
    Finds the intersection point of two lines.
    >>> intersection(1, 2, 5, -1, 2, 3)
    (1.0, 2.0)
    >>> intersection(1, 1, 2, 1, 1, 3)
    Traceback (most recent call last):
      ...
    ZeroDivisionError: division by zero
    """
    return 0, 0
```

Запустимо тест та бачимо, що перевірки виконалась успішно та тест не пройшов:

```shell
$ python -m doctest incorrect_main.py 
**********************************************************************
File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/2_doctest/v7/incorrect_main.py", line 4, in incorrect_main.intersection
Failed example:
    intersection(1, 2, 5, -1, 2, 3)
Expected:
    (1.0, 2.0)
Got:
    (0, 0)
**********************************************************************
1 items had failures:
   1 of   1 in incorrect_main.intersection
***Test Failed*** 1 failures.
```

# Пакет unittest зі стандартної бібліотеки Python [*]

\* unittest — Unit testing framework https://docs.python.org/3/library/unittest.html

У стандартній бібліотеці Python вбудований фреймворк для написання автоматизованих тестів, що реалізований в рамках пакету “unittest”. Незважаючи на назву, даний фреймворк може використовуватись для автоматизованих тестів будь-якого рівня, від юніт-тестів, до API-тестів.

## Організація тестів

На відміну від тестів у документації, при використанні пакету unittest тести знаходяться в окремому файлі. Як правило цей файл називають назвою модуля, що тестується, з префіксом “test_”. Самі тести знаходяться в методах класів, що наслідуються від базового класу “unittest.TestCase”. Назви методів тестів також починаються з префікса “test”, за яким слідує назва тесту, методи, що не починаються з префіксу “test” не будуть тестами та можуть бути допоміжними методами.

`test_main.py`
```python
import unittest

class TestMain(unittest.TestCase):

    def test_intersection(self):
        pass
```

## Запуск тестів

Як і пакет doctest, пакет unittest дозволяє запускати тести при використанні його як команди. Запустимо створений модуль з одним пустим тестом.

```shell
$ python -m unittest test_main.py 
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
```

## Перевірки

Тепер змінимо код тесту, щоб він перевіряв правильність виконання функції, що тестується.

`test_main.py`
```python
import unittest
from main import intersection

class TestMain(unittest.TestCase):

    def test_intersection(self):
        result = intersection(1, 2, 5, -1, 2, 3)
        if result != (1, 2):
            raise Exception()
```

Запустимо тест та бачимо, що він виконується успішно

```shell
$ python -m unittest test_main.py 
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
```

Тепер запустимо аналогічний тест, що використовує некоректну версію функції:

```shell
$ python -m unittest test_incorrect_main.py 
E
======================================================================
ERROR: test_intersection (test_incorrect_main.TestMain)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/3_unittest/v2/test_incorrect_main.py", line 9, in test_intersection
    raise Exception()
Exception

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
```

Бачимо, що тест завершується помилкою, це показує з буква замість крапки на початку виводу. 

Звичайно постійно вручну викликати “raise Exception()“ не надто зручно, тому розглянемо інші варіанти.

### Інструкція assert

Раніше ми вручну викидали виняток, однак Python має інструкцію “assert”, що дозволяє викидати винятки при невиконанні умови з меншою кількістю коду.

Інструкція assert приймає умову, при виконання якої нічого не відбувається, а при невиконання — викидається виняток AssertionError. Також можна передати опціональний параметр з додатковими даними для винятку з поясненням помилки чи будь-якими даними для полегшення ідентифікації причин помилки. Відповідно є два варіанти використання інструкції assert:

```python
assert condition
assert condition, data
```

Якщо інструкція assert була б функцією, то вона мала б наступний вигляд:

```python
def _assert(condition, data=None):
    if not condition:
        raise AssertionError(data)
```

Тепер використаємо інструкцію assert у тесті.

`test_main.py`
```python
import unittest
from main import intersection

class TestMain(unittest.TestCase):

    def test_intersection(self):
        result = intersection(1, 2, 5, -1, 2, 3)
        assert (1, 2) == result
```

Запустимо тест, щоб переконатись в коректній роботі інструкції assert.

```shell
$ python -m unittest test_main.py 
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
```

Тепер запустимо аналогічний тест з інструкцією assert для некоректної версії функції.

```shell
$ python -m unittest test_incorrect_main.py
F
======================================================================
FAIL: test_intersection (test_incorrect_main.TestMain)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/3_unittest/v3/test_incorrect_main.py", line 8, in test_intersection
    assert (1, 2) == result
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
```

Бачимо, що був викинутий виняток AssertionError, однак ми не передали ніяких додаткових даних, що можуть допомогти в ідентифікації проблеми при непроходженні тесту, тому передамо як дані, наприклад, отриманий неправильний результат.

`test_main.py`
```python
import unittest
from main import intersection

class TestMain(unittest.TestCase):

    def test_intersection(self):
        result = intersection(1, 2, 5, -1, 2, 3)
        assert (1, 2) == result, result
```

Тепер знову запустимо такий же ж тест для некоректної версії функції.

```shell
$ python -m unittest test_incorrect_main.py
F
======================================================================
FAIL: test_intersection (test_incorrect_main.TestMain)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/3_unittest/v4/test_incorrect_main.py", line 8, in test_intersection
    assert (1, 2) == result, result
AssertionError: (0, 0)

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
```

З виводу “AssertionError: (0, 0)” бачимо, що у виняток був переданий результат отриманий від функції, що може допомогти при при визначенні причини проблеми при непроходженні тесту.

### Методи assert класу unittest.TestCase

Клас “unittest.TestCase” має ряд методів для різних видів перевірок. Використаємо один з них, а саме “assertEqual” для перевірки еквівалентності значень.

`test_main.py`
```python
import unittest
from main import intersection

class TestMain(unittest.TestCase):

    def test_intersection(self):
        result = intersection(1, 2, 5, -1, 2, 3)
        self.assertEqual((1, 2), result)
```

Запустимо даний тест:

```shell
$ python -m unittest test_main.py 
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
```

Тепер запустимо даний тест з некоректною версією функції:

```shell
$ python -m unittest test_incorrect_main.py 
F
======================================================================
FAIL: test_intersection (test_incorrect_main.TestMain)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/ihorpyvovarnyk/Workspace/university-python/L13/3_unittest/v5/test_incorrect_main.py", line 8, in test_intersection
    self.assertEqual((1, 2), result)
AssertionError: Tuples differ: (1, 2) != (0, 0)

First differing element 0:
1
0

- (1, 2)
+ (0, 0)

----------------------------------------------------------------------
Ran 1 test in 0.002s

FAILED (failures=1)
```

З виводу бачимо, що при невиконанні умови викидається виняток “AssertionError”, що містить деталі про різницю між очікуваним та отриманим значенням.

“unittest.TestCase” має і ряд інших методів на різні випадки:

| Метод | Перевіряє, що ...  | Доступний з версії Python  |
|---------------------------|----------------------|-----|
| assertEqual(a, b)         | a == b               |     |
| assertNotEqual(a, b)      | a != b               |     |
| assertTrue(x)             | bool(x) is True      |     |
| assertFalse(x)            | bool(x) is False     |     |
| assertIs(a, b)            | a is b               | 3.1 |
| assertIsNot(a, b)         | a is not b           | 3.1 |
| assertIsNone(x)           | x is None            | 3.1 |
| assertIsNotNone(x)        | x is not None        | 3.1 |
| assertIn(a, b)            | a in b               | 3.1 |
| assertNotIn(a, b)         | a not in b           | 3.1 |
| assertIsInstance(a, b)    | isinstance(a, b)     | 3.1 |
| assertNotIsInstance(a, b) | not isinstance(a, b) | 3.1 |


























